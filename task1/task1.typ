#import "@preview/gentle-clues:1.2.0": *
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()
#codly(
  languages: codly-languages,
  number-format: none,
  zebra-fill: none
)

#set page(margin: (
  top: 1.5cm,
  bottom: 1.5cm,
  left: 1.5cm,
  right: 1.5cm, ))

#set text(font: "Avenir Next")
#show raw: set text(font: "Geist Mono")

#show link: set text(fill: blue)
#show link: it => underline(it)

= Задание 1: Считаем слова

== Что такое ```sh wc```?

#v(0.5em)

*```sh wc```* (word counter) --- это утилита, используемая для подсчёта
_символов_, _слов_ и _строк_ в произвольном тексте. Эта утилита входит в базовый
набор #link("https://ru.wikipedia.org/wiki/GNU_Coreutils")[GNU Coreutils], что
означает, что вы скорее всего найдёте её уже установленной на _Linux_, _MacOS_,
_\*BSD_ и даже _Windows_, если вы установили окружение MinGW для работы с С/C++.
Можете проверить доступность у себя wc, открыв терминал и написав там
```sh wc```.

#experiment(title: [Использование ```sh wc```])[
  Если мы отдадим ```sh wc``` в качестве аргумента файл, то в ответ получим 3
  числа и ещё раз название файла. Файл `the_laughing_heart.txt` поставляется
  вместе с заданием.

  ```sh
  $ wc the_laughing_heart.txt
      20      98     495 the_laughing_heart.txt
  ```

  В выводе ```sh wc```:
  - 20 --- число строк, а точнее число символов переноса строк ```c '\n'```;
  - 98 --- число слов;
  - 495 --- число символов, включая пробелы и символы переноса строк.
]

== Постановка задачи

=== Часть 1: чтение из файла

Необходимо реализовать утилиту ```sh wc```, которая будет считать  количество
символов, слов и строк внутри заданного файла. Но в отличие от оригинального
```sh wc```, наша реализация должна выводить 3 строки: на первой число строк,
на второй --- число слов, а на третьей --- число символов. Название файла
выводить не нужно. Если файл с таким названием не существует, будем выводить
ошибку.

Будем считать, что все символы входного файла взяты из таблицы ASCII (то есть
не надо учитывать кириллические символы). В качестве пробельных символов наша
реализация ```sh wc``` должна ожидать:
- обычный пробел: ```c ' '```;
- табуляция: ```c '\t'```;
- перенос строки: ```c '\n'```;
- возврат каретки (перемещает курсор в начало строки без перехода на следующую
  строку): ```c '\r'```;
- вертикальная табуляция: ```c '\v'```.

#example(title: [Пример использования нашего решения])[
  Допустим, мы написали решение в файле `main.c`. Скомпилируем это решение с
  помощью `gcc`, указав название для исполняемого файла с помощью флага `-o`:
  ```sh
  $ gcc -o my-wc main.c
  ```

  Ожидается, что наш исполняемый файл можно использовать следующим образом:
  ```sh
  $ ./my-wc the_laughing_heart.txt
  20
  98
  495
  ```
]

#idea(title: "Подсказка")[
  Для решения могут быть полезны функции ```c fopen()```, ```c fclose()``` и
  ```c fgetc()```. Но вы можете написать и иное решение, которое ими не
  пользуется.
]

=== Часть 2: чтение из стандартного потока ввода

#experiment(title: [Использование ```sh wc```])[
  Оригинальный ```sh wc``` ещё умеет читать текст из стандартного потока ввода.
  На примере ниже, мы запустили ```sh wc```, не передав файл в аргументах, и он
  начал ждать от нас ввода с клавиатуры. Мы ввели строчку текста, нажали на
  `Enter` и всё ещё ничего не произошло --- тут перенос строки не является
  обозначением конца ввода. Чтобы сообщить ```sh wc```, что это конец и больше
  мы не планируем что-либо печатать, нужно нажать сочетание клавиш `Ctrl+D`,
  после чего мы получим вывод и работа ```sh wc``` завершится.

  ```sh
  $ wc
  i am typing this text myself
       1       6      29
  ```

  Однако в стандартный поток ввода мы можем вводить текст не только с клавиатуры,
  мы можем воспользоваться, например, программой ```sh cat``` для получения
  содержимого файла и перенаправить её вывод в стандартный поток ввода
  ```sh wc``` с помощью вертикальной черты:
  ```sh
  $ cat the_laughing_heart.txt | wc
      20      98     495
  ```
]

Давайте теперь изменим работу нашей программы так, чтобы она читала текст не из
файла, а из стандартного потока ввода (`stdin`), если в качестве аргумента не
был передан файл. Точно так же, как и ```sh wc```.

Соответственно:
- если в качестве первого аргумента командной строки указано название
  файла, то необходимые данные считаются для этого файла;
- если название файла не указано, то вместо него данные считаются для строк,
  которые подаются в стандартный поток ввода.

#example(title: [Пример использования нашего решения])[
  Опять же, ожидается, что нашим решением можно пользоваться точно так же, как
  и оригинальным ```sh wc```, за исключением формата вывода:

  ```sh
  $ cat the_laughing_heart.txt | ./my-wc
  20
  98
  495
  ```
]

#idea(title: "Подсказка")[
  Стандартный поток ввода можно читать как обычный файл. В заголовочном файле
  `stdio.h` уже объявлено имя `stdin`.
]
